from heapq import heappop, heappush
from collections import Counter


class Huffman:
    def __init__(self, freq, char=None, left=None, right=None):
        self.char = char
        self.freq = freq
        self.left = left
        self.right = right
    
    def __lt__(self, other):
        return self.freq < other.freq
    
    def __add__(self, other):
        return Huffman(self.freq+other.freq, left=self, right=other)
    
    @property
    def is_leaf(self):
        return not self.left and not self.right
    


def encode(data):
    tree_root = tree(data)
    mapping_res = mapping(tree_root)

    return "".join(mapping_res[char] for char in data), tree_root


def decode(data, tree_root):
    node = tree_root
    decoded = ""

    i = 0
    while i < len(data):
        while not node.is_leaf:
            node = node.left if data[i] == "0" else node.right
            i += 1
        
        decoded += node.char
        node = tree_root
    
    return decoded


def tree(data):
    nodes = []
    
    for pair in Counter(data).items():
        heappush(nodes, Huffman(*reversed(pair)))
    
    while len(nodes) > 1:
        left = heappop(nodes)
        right = heappop(nodes)
        heappush(nodes, left+right)
    
    return nodes[0]


def mapping(node):
   return _mapping(node, {}, "")


def _mapping(node, res, bits):
    try:
        _mapping(node.left, res, bits+"0")
        _mapping(node.right, res, bits+"1")
    except AttributeError:
        pass
    
    res[node.char] = bits
    return res


def main():
    while True:
        data = input()
        encoded, tree_root = encode(data)

        print(encoded)
        print(decode(encoded, tree_root))


try:
    main()
except KeyboardInterrupt:
    quit()

text = """Переповнення
У процесі роботи алгоритму стиснення ваги вузлів у дереві кодування Гаффмана неухильно зростають. Перша проблема виникає тоді, коли вага кореня дерева починає перевищувати місткість комірки, в якій він зберігається. Як правило, це 16-бітове значення і, отже, не може бути більшим, ніж 65535. Друга проблема, яка заслуговує ще більшої уваги, може виникнути значно раніше, коли розмір найдовшого коду Гаффмана перевищує місткість комірки, яка використовується для того, щоб передати його у вихідний потік. Декодеру все одно, якої довжини код він декодує, оскільки він рухається зверху вниз по дереву кодування, вибираючи з вхідного потоку по одному біту. А кодер повинен починати від листа дерева і рухатися вгору до кореня, збираючи біти, які потрібно передати. Зазвичай для цього використовують змінну цілого типу і, коли довжина коду Гаффмана перевершує розмір цілого типу в бітах, настає переповнення.

Можна довести, що максимальну довжину код Гаффмана для повідомлень з одним і тим самим вхідним алфавітом матиме, якщо частоти символів утворюють послідовність Фібоначчі. Повідомлення з частотами символів, рівними числам Фібоначчі до Fib(18), — це відмінний спосіб випробувати роботу програми стиснення за Гаффманом.

Масштабування ваг вузлів дерева Гаффмана
Беручи до уваги сказане вище, алгоритм поновлення дерева Гаффмана повинен бути змінений таким чином: при збільшенні ваги потрібно перевіряти її на досягнення допустимого максимуму. Якщо ми досягли максимуму, то необхідно «масштабувати» вагу, зазвичай поділивши вагу листка на ціле число, наприклад, 2, а потім перерахувавши ваги всіх інших вузлів.

Однак при діленні ваги навпіл виникає проблема, пов'язана з тим, що після виконання цієї операції дерево може змінити свою форму. Пояснюється це тим, що ми ділимо цілі числа і при діленні відкидаємо дробову частину.

Правильно організоване дерево Гаффмана після масштабування може мати форму, яка значно відрізняється від початкової. Це відбувається тому, що масштабування призводить до втрати точності нашої статистики. Але зі збором нової статистики наслідки цих «помилок» практично сходять нанівець. Масштабування ваги — досить дорога операція, оскільки вона призводить до необхідності заново будувати все дерево кодування. Але оскільки необхідність у ній виникає відносно рідко, то з цим можна змиритися.

Виграш від масштабування

Масштабування ваги вузлів дерева через певні інтервали дає несподіваний результат. Незважаючи на те, що при масштабуванні відбувається втрата точності статистики, тести показують, що воно призводить до кращих показників стиснення, ніж якщо б масштабування відкладалося. Це можна пояснити тим, що поточні символи стисненого потоку більше «схожі» на своїх близьких попередників, ніж на тих, які зустрічалися набагато раніше. Масштабування призводить до зменшення впливу «давніх» символів на статистику і до збільшення впливу на неї «недавніх» символів. Це дуже складно виміряти кількісно, ​​але, в принципі, масштабування позитивно впливає на ступінь стиснення інформації. Експерименти з масштабуванням в різних точках процесу стиснення показують, що ступінь стиснення сильно залежить від моменту масштабування ваги, але не існує правила вибору оптимального моменту масштабування для програми, орієнтованої на стиск будь-яких типів інформації.

Застосування
Стиснення даних Гаффмана застосовується під час стиснення фото- і відеозображень (JPEG, стандарти стиснення MPEG), в архіваторах (PKZIP, LZH та інших), в протоколах передачі даних MNP5 і MNP7.

"""